CREATE OR REPLACE PROCEDURE SF_METRICS.P_TASK_FACT (DAYS_START INTEGER DEFAULT 2, DAYS_END INTEGER DEFAULT 0)
RETURNS VARIANT
LANGUAGE SQL
COMMENT = 'Update a Fact table for Task Queries'
AS
$$
BEGIN
  INSERT INTO SF_METRICS.TASK_FACT (
    LOGDATE
    , QUERY_ID
    , SESSION_ID
    , QUERY_PARAMETERIZED_HASH
    , TASK_DATABASE
    , TASK_SCHEMA
    , TASK_NAME
    , IS_ROOT
    , SCHEDULED_FROM
    , ROLE_NAME
    , WAREHOUSE_NAME
    , WAREHOUSE_SIZE
    , QUERY_CREDITS_USED
    , CREDITS_ATTRIBUTED_COMPUTE
    , CREDITS_SERVERLESS
    , CREDITS_USED_QUERY_ACCELERATION
    , EXECUTION_STATUS
    , ERROR_CODE
    , ERROR_MESSAGE
    , START_TIME
    , END_TIME
    , TOTAL_ELAPSED_TIME
    , QUEUED_OVERLOAD_TIME
    , BYTES_SCANNED
    , PARTITIONS_SCANNED
    , PARTITIONS_TOTAL
    , BYTES_SPILLED_TO_LOCAL_STORAGE
    , BYTES_SPILLED_TO_REMOTE_STORAGE
    , ROWS_WRITTEN_TO_RESULT
    , ROWS_INSERTED
    , ROWS_UPDATED
    , ROWS_DELETED
    , CREDITS_USED_CLOUD_SERVICES
    , COUNT_QUERIES
  )
  WITH
    task_runs as (
      SELECT
        LOGDATE
        , DATABASE_NAME as TASK_DATABASE
        , SCHEMA_NAME as TASK_SCHEMA
        , NAME as TASK_NAME
        , QUERY_ID
        , QUERY_PARAMETERIZED_HASH
        , COALESCE(QUERY_START_TIME, SCHEDULED_TIME) as START_TIME
        , COMPLETED_TIME as END_TIME
        , DATEDIFF('millisecond', QUERY_START_TIME, COMPLETED_TIME) as TOTAL_ELAPSED_TIME
        , STATE AS EXECUTION_STATUS
        , ERROR_CODE
        , ERROR_MESSAGE
        , SCHEDULED_FROM
      FROM SF_METRICS.TASK_HISTORY
      WHERE 
        LOGDATE >= CURRENT_DATE() - :DAYS_START
        AND LOGDATE < CURRENT_DATE() - :DAYS_END
        AND QUERY_ID NOT IN (
          SELECT QUERY_ID
          FROM SF_METRICS.TASK_FACT
          WHERE LOGDATE >= CURRENT_DATE() - :DAYS_START AND LOGDATE < CURRENT_DATE() - :DAYS_END
        )
    ),
    first_query as (
      SELECT
        QUERY_ID
        , SESSION_ID
        , WAREHOUSE_NAME
        , WAREHOUSE_SIZE
        , ROLE_NAME
      FROM SF_METRICS.QUERY_HISTORY
      WHERE
        QUERY_ID IN (SELECT QUERY_ID FROM task_runs)
        AND LOGDATE >= CURRENT_DATE() - :DAYS_START
        AND LOGDATE < CURRENT_DATE() - :DAYS_END
    ),
    session_cost as (
      SELECT
        SESSION_ID
        , SUM(QUERY_CREDITS_USED) as CREDITS
      FROM SF_METRICS.QUERY_CREDITS
      WHERE USER_NAME = 'SYSTEM'
        AND SESSION_ID IN (
          SELECT SESSION_ID
          FROM first_query
        )
        AND LOGDATE >= CURRENT_DATE() - :DAYS_START
        AND LOGDATE < CURRENT_DATE() - :DAYS_END
      GROUP BY SESSION_ID
    ),
    session_totals as (
      SELECT
        SESSION_ID
        , SUM(BYTES_SCANNED) as BYTES_SCANNED
        , SUM(PARTITIONS_SCANNED) as PARTITIONS_SCANNED
        , SUM(PARTITIONS_TOTAL) as PARTITIONS_TOTAL
        , SUM(BYTES_SPILLED_TO_LOCAL_STORAGE) as BYTES_SPILLED_TO_LOCAL_STORAGE
        , SUM(BYTES_SPILLED_TO_REMOTE_STORAGE) as BYTES_SPILLED_TO_REMOTE_STORAGE
        , SUM(CREDITS_USED_CLOUD_SERVICES) as CREDITS_USED_CLOUD_SERVICES
        , SUM(ROWS_WRITTEN_TO_RESULT) as ROWS_WRITTEN_TO_RESULT
        , SUM(ROWS_INSERTED) AS ROWS_INSERTED
        , SUM(ROWS_UPDATED) AS ROWS_UPDATED
        , SUM(ROWS_DELETED) AS ROWS_DELETED
        , SUM(QUEUED_OVERLOAD_TIME) as QUEUED_OVERLOAD_TIME
        , COUNT(*) as COUNT_QUERIES
      FROM SF_METRICS.QUERY_HISTORY
      WHERE
        SESSION_ID IN (SELECT SESSION_ID from first_query)
        AND LOGDATE >= CURRENT_DATE() - :DAYS_START
        AND LOGDATE < CURRENT_DATE() - :DAYS_END
      GROUP BY SESSION_ID
    ),
    attributed as (
      SELECT
        COALESCE(ROOT_QUERY_ID, QUERY_ID) as QUERY_ID
        , SUM(CREDITS_ATTRIBUTED_COMPUTE) as CREDITS_ATTRIBUTED
        , SUM(CREDITS_USED_QUERY_ACCELERATION) as CREDITS_USED_QUERY_ACCELERATION
      FROM SF_METRICS.QUERY_ATTRIBUTION_HISTORY
      WHERE
        COALESCE(ROOT_QUERY_ID, QUERY_ID) IN (SELECT QUERY_ID from first_query)
        AND LOGDATE >= CURRENT_DATE() - :DAYS_START
        AND LOGDATE < CURRENT_DATE() - :DAYS_END
      GROUP BY COALESCE(ROOT_QUERY_ID, QUERY_ID)
    ),
    task_roots as (
      SELECT
        DATABASE_NAME as ROOTS_DB
        , SCHEMA_NAME as ROOTS_SCHEMA
        , NAME as ROOTS_NAME
        , CASE
          WHEN MAX_BY(ROOT_TASK_ID, GRAPH_VERSION_CREATED_ON) = MAX_BY(ID, GRAPH_VERSION_CREATED_ON)
          THEN TRUE ELSE FALSE
        END as IS_ROOT
      FROM SNOWFLAKE.ACCOUNT_USAGE.TASK_VERSIONS
      WHERE 1=1 
      GROUP BY ROOTS_DB, ROOTS_SCHEMA, ROOTS_NAME
    ),
    serverless as (
      SELECT
        DATABASE_NAME as SERVERLESS_DB
        , SCHEMA_NAME as SERVERLESS_SCHEMA
        , TASK_NAME as SERVERLESS_NAME
        , START_TIME as SERVERLESS_START
        , END_TIME as SERVERLESS_END
        , SUM(CREDITS_USED) as SERVERLESS_CREDITS
        , ROW_NUMBER() OVER(ORDER BY '1') as TASK_PERIOD_ID
      FROM SF_METRICS.SERVERLESS_TASK_HISTORY st
      WHERE LOGDATE >= CURRENT_DATE() - :DAYS_START
        AND LOGDATE < CURRENT_DATE() - :DAYS_END
      GROUP BY SERVERLESS_DB, SERVERLESS_SCHEMA, SERVERLESS_NAME, SERVERLESS_START, SERVERLESS_END
    ),
    serverless_assigned as (
      SELECT
        QUERY_ID
        , SUM(AVG_CREDITS) as SERVERLESS_CREDITS
      FROM (
        SELECT
          QUERY_ID
          , TASK_PERIOD_ID
          , AVG(serverless.SERVERLESS_CREDITS) OVER (PARTITION BY TASK_PERIOD_ID) as AVG_CREDITS
        FROM task_runs
        INNER JOIN serverless ON (
          task_runs.TASK_DATABASE = serverless.SERVERLESS_DB
          AND task_runs.TASK_SCHEMA = serverless.SERVERLESS_SCHEMA
          AND task_runs.TASK_NAME = serverless.SERVERLESS_NAME
          AND task_runs.START_TIME <= serverless.SERVERLESS_END
          AND task_runs.END_TIME >= serverless.SERVERLESS_START
        )
      )
      GROUP BY QUERY_ID
    )
  SELECT
    task_runs.LOGDATE
    , task_runs.QUERY_ID
    , first_query.SESSION_ID
    , task_runs.QUERY_PARAMETERIZED_HASH
    , task_runs.TASK_DATABASE
    , task_runs.TASK_SCHEMA
    , task_runs.TASK_NAME
    , task_roots.IS_ROOT
    , task_runs.SCHEDULED_FROM
    , first_query.ROLE_NAME
    , first_query.WAREHOUSE_NAME
    , first_query.WAREHOUSE_SIZE
    , COALESCE(session_cost.CREDITS, serverless_assigned.SERVERLESS_CREDITS) as QUERY_CREDITS_USED
    , attributed.CREDITS_ATTRIBUTED as CREDITS_ATTRIBUTED_COMPUTE
    , serverless_assigned.SERVERLESS_CREDITS as SERVERLESS_CREDITS
    , attributed.CREDITS_USED_QUERY_ACCELERATION as CREDITS_USED_QUERY_ACCELERATION
    , task_runs.EXECUTION_STATUS
    , task_runs.ERROR_CODE
    , task_runs.ERROR_MESSAGE
    , task_runs.START_TIME
    , task_runs.END_TIME
    , task_runs.TOTAL_ELAPSED_TIME
    , session_totals.QUEUED_OVERLOAD_TIME
    , session_totals.BYTES_SCANNED
    , session_totals.PARTITIONS_SCANNED
    , session_totals.PARTITIONS_TOTAL
    , session_totals.BYTES_SPILLED_TO_LOCAL_STORAGE
    , session_totals.BYTES_SPILLED_TO_REMOTE_STORAGE
    , session_totals.ROWS_WRITTEN_TO_RESULT
    , session_totals.ROWS_INSERTED
    , session_totals.ROWS_UPDATED
    , session_totals.ROWS_DELETED
    , session_totals.CREDITS_USED_CLOUD_SERVICES
    , session_totals.COUNT_QUERIES
  FROM task_runs
    LEFT JOIN task_roots ON (
      task_runs.TASK_DATABASE = task_roots.ROOTS_DB
      AND task_runs.TASK_SCHEMA = task_roots.ROOTS_SCHEMA
      AND task_runs.TASK_NAME = task_roots.ROOTS_NAME
    )
    LEFT JOIN first_query ON (task_runs.QUERY_ID = first_query.QUERY_ID)
    LEFT JOIN session_cost ON (first_query.SESSION_ID = session_cost.SESSION_ID)
    LEFT JOIN session_totals ON (first_query.SESSION_ID = session_totals.SESSION_ID)
    LEFT JOIN attributed ON (first_query.QUERY_ID = attributed.QUERY_ID)
    LEFT JOIN serverless_assigned ON (task_runs.QUERY_ID = serverless_assigned.QUERY_ID)
  ;

  RETURN TRUE;
EXCEPTION
  WHEN OTHER THEN
    RAISE;
END;
$$
;
